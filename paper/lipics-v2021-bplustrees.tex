
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

% listing language definitions for several language of the following kinds:
% * ontology languages
% * markup languages
% * other semantic web languages
% * other languages occurring in the above contexts
% 
% for some related languages see also https://svn.kwarc.info/repos/stex/trunk/sty/etc/lstomdoc.sty
% 
% compiled by Christoph Lange (Universität Bremen, Jacobs University Bremen, University of Birmingham)
% 2010–2013
% math.semantic.web@gmail.com
% 
% https://github.com/clange/latex
% 
% For Mizar, see https://raw.github.com/JUrban/mizarmode/master/lstlangmizar.sty by Josef Urban

% Isabelle
% http://isabelle.in.tum.de
% partial specification; poor man's alternative to Isabelle's own LaTeX export
% but see also pmisabelle.sty
%\newif\iflst@instring\lst@instringfalse
%\newcommand*{\lst@eat}[1]{}%
%\newcommand*{\togglelst@instring}{%
%\upshape%
%\global\lst@instringfalse''
%}
\RequirePackage{xcolor}
\definecolor{IsabelleTypeColor}{HTML}{9f2ae5}
% Strings usually have this background color
% however listings has currently not support for selected background coloring
\definecolor{IsabelleStringBackground}{HTML}{535353}
\definecolor{IsabelleKeywordColor}{HTML}{2f769e}
\lstdefinelanguage{Isabelle}[]{ML}%
{morekeywords={%
abbreviation,% added by NM
assume,%
assumes,%
by,%
def,%
datatype,% added by NM
definition,% added by NM
fix,%
fixes,%
from,%
have,%
lemma,%
obtain,%
proof,%
partial\_function,%
qed,%
return,%
show,%
shows,%
theorem,%
typedef,%
try,%
unfolding,%
using,%
where,%
},
% modyfied to display highlighting inside strings
%morestring=**[d][\color{IsabelleStringBackground}]{"},
% and highlight type prefixes (')
%moredelim=[s][\color{IsabelleTypeColor}]{'}{\ },
%added by NM
moredelim=[s][\color{IsabelleStringBackground}]{(*}{*)},
basicstyle=\itshape,%
keywordstyle=\upshape\bfseries,%\color{IsabelleKeywordColor},%
columns=fullflexible,%
showstringspaces=false,%
mathescape,%
}[keywords,comments]


%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{A Verified Implementation of B$^+$-Trees in Isabelle/HOL} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Niels Mündler}{Department of Computer Science, ETH Zurich, Switzerland}{n.muendler@tum.de}{https://orcid.org/0000-0003-3851-2557}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Tobias Nipkow}{Department of Informatics, Technical University of Munich, Germany}{nipkow@in.tum.de}{https://orcid.org/0000-0003-0730-515X}{}

\author{Peter Lammich}{Department of Computer Science, The University of Manchester, Great-Britain}{lammich@in.tum.de}{https://orcid.org/0000-0003-3576-0504}{}

\authorrunning{N. Mündler, T. Nipkow and P. Lammich} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Niels Mündler} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\begin{CCSXML}
    <ccs2012>
       <concept>
           <concept_id>10003752.10003790.10011742</concept_id>
           <concept_desc>Theory of computation~Separation logic</concept_desc>
           <concept_significance>500</concept_significance>
           </concept>
     </ccs2012>
\end{CCSXML}
    
\ccsdesc[500]{Theory of computation~Separation logic}
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Separation Logic, Verification, Refinement} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\btree}{B$^+$-Tree}
\newcommand{\btrees}{B$^+$-Trees}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
    The abstract will surely become longer at some point.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

This will be the introduction. There will be more text.

\subsection{Related Work}
\label{sec:related_work}

Ernst verified a simplified version of \btrees that does
not have links between leaf nodes.

Malecha already built and verified \btrees \cite{}.
In their approach, they chose an intermediate layer of a functional
data structure that explicitely stores pointers to their heap embedded
correspondence.

\subsection{Contributions}
\label{sec:contributions}

We provide an alternative approach to verifying \btree implementations,
by separating the functional specification and the imperative implementation.
This allows for complex relationships to be validated on a purely
functional level, while on the imperative level
only refinement of the abstract operations needs to be shown.
The approach allowed us to supplement the implementation
with an efficient binary search on the node level
and eventually provide an efficient range query iterator
on top of a list element iterator.


\section{\btrees\ and Approach}
\label{sec:approach}

The \btree is a ubiquitous data structure to efficiently retrieve and manipulate
indexed data stored on storage devices with slow memory access \cite{DBLP:journals/csur/Comer79}.
They are $n$-ary balanced search trees, where $n$ is a free parameter.
We specify them as implementing a set interface,
where all elements in the leaves are comprising the content of an abstract set.
The inner nodes only contain separators to guide the recursive navigation through the tree.

Further the leaves usually contain pointers
to the next leaf, allowing for efficient iterators and range queries.

The goal of this work is to define this data structure
and implement and verify efficient heap-based imperative operations on them.
For this purpose, we introduce a functional, algebraic definition and
specify all invariants on this level.
It is important to note that this representation is not complete,
as we can not express the aliased pointers to the next leaf in a meaningful
way on the algebraic level.
However important structural invariants, such as sortedness and balancedness
can be verified.

In a second step an imperative definition is introduced,
that takes care of the refinement of linked lists to arrays in the heap
and introduces (potentially shared) pointers instead of algebraic structures.
Using a refinement relationship, we can prove that an imperative refinement
of the functional specification preserves the structural invariants
of the imperative tree on the heap.
The only remaining proof obligation on this level is to ensure the correctness
of the leaf pointers.


\subsection{Definitions}
\label{sec:data_structure_defs}

% TODO shorten

The algebraic \btree is defined as follows:

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-def]
    datatype 'a bplustree = LNode ('a list) | Node (('a bplustree * 'a) list) ('a bplustree)
\end{lstlisting}

Every node contains a list of \textit{keys} (also \textit{separators}, and \textit{subtrees} (\textit{children}),
that represent further \btree nodes.
The separators and subtrees may be considered interleaved within a node,
such that we can speak of a subtree to the left of a separator and
a subtree to the right of a separator,
where for a separator at index $i$ we mean the subtree in the respective
subtree list at index $i$ and $i+1$ respectively.
Note that this already implies that the list of subtrees is one
longer than the list of separators - we refer to the last subtree
as the \textit{last} or \textit{dangling} subtree.
The leafs contain a list of \textit{values}.
A \btree with above structure must fulfill the three properties
\textit{balancedness}, \textit{order} and \textit{sortedness}.

\textbf{Balancedness} requires
that each path from the root to any leaf has the same length $h$.
In other words, the height of all trees in one level of the tree must be equal,
where the height is the maximum path length to any leaf.

Further the keys and values must be sorted within the tree.
This actually comprises two properties: \textbf{Alignment}, which means that all keys stored
in the subtree to the left of a separator are smaller than the value of the separator
and all indices in the subtree to the right are greater or equal.
\footnote{
    The exact direction of the part that may contain equal element is a design choice.
}
Further all keys within a node should maintain a sorted order,
as well as all the values within a leaf, which we express directly
as \textbf{sortedness} of the concatenated lists.

In general terms, the property of \textbf{order} ensures a certain minimum and maximum
number of subtrees for each node.
A \btree is of order $k$, if each internal node has at least $k+1$
subtrees and at most $2k+1$.
The root is required to have a minimum of 2 and a maximum of $2k+1$ subtrees.
We require that $k$ be strictly positive.
%TODO insert reason?

The definition in \autoref{lst:btree-def} described an algebraic data structure.
It is by construction finite but also forbids sharing of pointers or local updates.
In the final imperative setting we are therefore looking at a node that stores not trees
but pointers\footnote{\textbf{ref} or ref option if it is potentially null} to other trees and stores values in arrays.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-imp-def]
datatype 'a btnode =
  Btnode "('a btnode ref option *'a) pfarray" "'a btnode ref" |
  Btleaf "'a pfarray" "'a btnode ref option"
\end{lstlisting}

All elements of this tree can and will be stored on a heap, where \textbf{ref} is a pointer
to another element in the heap.
With this setup, it is possible to modify elements on the heap or share pointers.
However, it is troublesome to conduct direct proofs on this structure.
We therefore introduce a refinement relation to the algebraic data structure.
In later steps we can then show that this relation holds throughout operations on the imperative
tree and can thus imply relevant information on the obtained result and modified tree.

The relation is expressed as a separation logic formula that links an abstract tree to an
imperative data structure.
Since the shared leaf pointers are not part of the abstract tree,
they are further introduced to ensure correct linking of leafs.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-relation]
fun bplustree_assn :: "nat \<Rightarrow> ('a::heap) bplustree \<Rightarrow> 'a btnode ref \<Rightarrow> 'a btnode ref option \<Rightarrow> 'a btnode ref option \<Rightarrow> assn" where
  "bplustree_assn k (LNode xs) a r z =
 (\<exists>\<^sub>A xsi fwd.
      a \<mapsto>\<^sub>r Btleaf xsi fwd
    * is_pfa (2*k) xs xsi
    * \<up>(fwd = z)
    * \<up>(r = Some a)
  )" |
  "bplustree_assn k (Node ts t) a r z =
 (\<exists>\<^sub>A tsi ti tsi' tsi'' rs.
      a \<mapsto>\<^sub>r Btnode tsi ti
    * bplustree_assn k t ti (last (r#rs)) (last (rs@[z]))
    * is_pfa (2*k) tsi' tsi
    * \<up>(length tsi' = length rs)
    * \<up>(tsi'' = zip (zip (map fst tsi') (zip (butlast (r#rs)) (butlast (rs@[z])))) (map snd tsi'))
    * list_assn ((\<lambda> t (ti,r',z'). bplustree_assn k t (the ti) r' z') \<times>\<^sub>a id_assn) ts tsi''
    )"
\end{lstlisting}

\section{Set operations}
\label{sec:set}

The most important operations on \btrees are point querys and insertion.
There is a canon on their implementation which we followed in our approach.
Deletion is less commonly implemented and even less verified,
however we provide an a functional definition of a correct deletion operation.

\subsection{Functional Point Query}
\label{sec:functional_pq}

The point query operation is straightforward and serves as an introduction
to Isabelle/HOL notation.
For an inner node, find the correct subtree which must contain
the searched value if it is in the tree.
Inside the leaf node, obtain the value directly from the list of values.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:isin-def]
fun isin:: "'a bplustree \<Rightarrow> 'a \<Rightarrow> bool" where
  "isin (LNode ks) x = (isin_list x ks)" |
  "isin (Node ts t) x = (
      case split ts x of (_,(sub,sep)#rs) \<Rightarrow> (
             isin sub x
      )
   | (_,[]) \<Rightarrow> isin t x
  )"
\end{lstlisting}

Note that we assume here that a "split" and "isin\_list" operation exist,
that somehow obtain from a sorted list of key-value pairs or keys
the correct subtree-separator pair or result of operation.
These operations trivially exists, for example based on a linear search.
We abstract the operations away here such that we can freely substitute them in a
later stage, even with a binary search implementation.

Since this operation does not modify the tree involved at all,
we only need to show that it returns the correct value.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:isin-set-inorder]
theorem isin_set_inorder:
  assumes "sorted_less (leaves t)"
    and "aligned l t u"
  shows "isin t x = (x \<in> set (leaves t))"
\end{lstlisting}

%TODO imperative definition
\subsection{Imperative Point Query}
\label{sec:imperative_pq}

The imperative version of the point query is now a partial function
as without non-cyclicity assumptions about the tree input
we can not guarantee termination anymore.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:isin-imp-def]
partial_function (heap) isin :: "'a btnode ref \<Rightarrow> 'a \<Rightarrow>  bool Heap"
  where
    "isin p x = do {
  node \<leftarrow> !p;
  (case node of
     Btleaf xs _ \<Rightarrow> imp_isin_list x xs |
     Btnode ts t \<Rightarrow> do {
       i \<leftarrow> imp_split ts x;
       tsl \<leftarrow> pfa_length ts;
       if i < tsl then do {
         s \<leftarrow> pfa_get ts i;
         let (sub,sep) = s in
           isin (the sub) x
       } else
           isin t x
    }
)}"
\end{lstlisting}

Again, we assume that there are split functions that do node internal search operations for us
and themselves refine their functional equivalent.

In order to show that the function returns the correct result,
we merely show that it does the same operation on the imperative tree
as on the algebraic tree.
This proof can be done inductively on the structure of the abstract tree.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:isin-refines]
lemma  "k > 0 \<Longrightarrow> root_order k t \<Longrightarrow> sorted_less (inorder t) \<Longrightarrow> sorted_less (leaves t) \<Longrightarrow>
   <bplustree_assn k t ti r z>
     isin ti x
   <\<lambda>y. bplustree_assn k t ti r z * \<up>(abs_split_set.isin t x = y)>\<^sub>t"
\end{lstlisting}

The insertion operation and its proof largely line up with the approach to point queries.
However, an important aspect here is that we need to show that the leaf pointers
maintain correct linking after the operation.
This can only be shown on the imperative level as there is no abstract equivalent
to the shared pointers.


%\subsection{Functional Insert}
%\label{sec:functional_insert}
%
%The definition of insertion is largely lined up with the definition
%of point queries.
%
%\subsection{Imperative Insert}
%\label{sec:imperative_insert}
%
%One additional challenge here is to prove the correct initialization
%and modification of pointers in the leaves,
%as this cannot be proven on the abstract level, where these pointers
%have no correspondence.


\section{Range operations}
\label{sec:range}

On the functional level, the forwarding leaf pointers in each leaf
are not present, as this would require aliasing.
Therefore, iterators merely compute the concatenation
of all leaf contents in the trivial manner.
Range iterators then concatenate the correct parts of the
abstract tree.
Only when refining the operations, we will make use of the leaf pointers
to obtain an efficient implementation.

\subsection{Iterators}
\label{sec:imperative_iter}

From an implementation perspective, obtaining an iterator over the leafs
of a \btree is trivial.
We simply recurse down the tree to obtain the first leaf and from there follow leaf
pointers along the skirt of the tree.
However, from a refinement relation perspective the situation is a bit more intricate.
It is important to find a recursive formulation of the linked list in the leaf pointers.
At the same time, we want to maintain enough information about the remainder of the tree
to be able to reconstruct the assertion about the whole tree,
while separation logic forces us not to make statements about the contents of any memory location twice,
in order to keep the parts of the heap disjunct.

We therefore follow the approach of \cite{DBLP:conf/popl/MalechaMSW10} and
try to find an equivalent formulation that separates the whole tree in a
view on its inner nodes and the linked leaf node list.
The main idea to keep the heaps separate nontheless is to only
assert correct content of the leafs within the linked list part
and only assert equivalence of pointers in the inner nodes part.

A first attempt to use \autoref{lst:btree-relation} for this fails.
The reason is, that we can not express that the linked leaf nodes
are precisely the leaf nodes that the lowest level of inner nodes point to.
We can show that the whole tree can be separated into a linked list in the leafs
and inner nodes, but we can not show that we can necessarily "glue" the two views
back together and obtain a structurally consistent \btree.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-view-split-oneway]
lemma bplustree_leaf_nodes:
  "bplustree_assn k t ti r z \<Longrightarrow>\<^sub>A leaf_nodes_assn k (leaf_nodes t) r z * true"
\end{lstlisting}

% TODO graphic explaining the issue

In a second attempt we succeed by making the sharing explicit.
We extract from the whole tree the precise list of pointers to leaf nodes
in the correct order.
In the separated view, we now require that the pointers
in the lowest level of the inner node view are precisely the pointers
that are comprising the linked list view of the leafs.
A convenient fact is that this view on the tree that makes the leaf pointers explict
is equivalent to the view where we do not know precisely which pointers are in the leafs.
However, the statement is strong enough to guarantee that such a list exists.


\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-view-split]
lemma bplustree_extract_leafs:
    "bplustree_assn k t ti r z = (\<exists>\<^sub>Aleafptrs. bplustree_assn_leafs k t ti r z leafptrs)"

lemma bplustree_leaf_nodes_sep:
  "bplustree_assn_leafs k t ti r z lptrs = leaf_nodes_assn k (leaf_nodes t) r z lptrs * inner_nodes_assn k t ti r z lptrs"
\end{lstlisting}

In the work of Malecha \cite{DBLP:conf/popl/MalechaMSW10}, this
difference never occured, as the structure used there was a functional tree
that had each node directly annotated with the heap pointers.

Now to obtain an iterator on the leaf nodes of the tree,
we simply obtain the first leaf by a recursive function.
On the result, we can apply the above assertion split to realize
that we now have a pointer that provides a list-recursive
view on the leaf elements.

In a next step, we show that such a list view can be used
to define an imperative iterator over the refined list,
similar to how Lammich defines linked list iterators on abstract lists.

To really obtain an iterator that returns every single element of the
leaf nodes, rather than the leaf nodes or the contained arrays themselves,
we introduce a flattening iterator.
It takes an outer iterator over a data structure \textit{a} that returns elements of type \textit{b},
and inner iterator over the data structure \textit{b}.
The result is instantiated code that refines an iterator
over the concatenated list of elements refined by the outer iterator.

Using this structure, we obtain a function that creates an iterator
over the leafs of the original tree.
\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-view-split]
lemma leaf_elements_iter_init_rule:
  assumes "k > 0" "root_order k t"
  shows "<bplustree_assn k t ti r None>
    leaf_elements_iter_init ti
    <\<lambda>it. leaf_elements_iter k t ti r (leaves t) it>\<^sub>t"
\end{lstlisting}

\subsection{Range operations}
\label{sec:imperative_range}

One interesting note on the range iterators is, that a
straightforward proof of the correctness of the exact range iterator
failed at the attempt to recursively make a statement on
the leaf element iterators on the subtree.
A workaround is to just make a statement about the split tree first,
and later obtain the iterator only from manipulating the obtained leaf node.
This lead to the functional level being extended by two functions,
one that obtained the correct leaf node for the range iteration
and another one that manipulated the leaf node to obtain
the correct element-level iterator on all values.
On a second attempt, these two functions could then be imperatively
refined and verified.
Their concatenation then yields the intended result at no extra cost.

\section{Code extraction}

\subsection{Binary internal search}
\label{sec:imperative_split}

Due to the high abstraction of the proofs,
we can now provide different node internal search algorithms,
as long as they guarantee the required properties of the split function.
To this end we provide a linear search algorithm
and a binary search, the latter being commonly used in real world applications.

\subsection{Code export}
\label{sec:code_export}

From the imperative code shown,
Isabelle/HOL allows exports to a number of languages.

% TODO some analysis of the code generated? even necessary?

\section{Comparison and Conclusion}
\label{sec:conclusion}

We were able to define and verify a number of efficient operations
on imperative \btrees.
Namely we provide the basics with point and insertion querys.
Further we provide an efficient iterator on the leafs
and even give a range operation for a lower bound that
can be trivially extended to support an upper bound.
All operations are conducted on a \btree with linked leafs,
and conduct binary search within each node.

\end{document}
