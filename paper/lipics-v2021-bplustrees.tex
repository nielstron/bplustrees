
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

% listing language definitions for several language of the following kinds:
% * ontology languages
% * markup languages
% * other semantic web languages
% * other languages occurring in the above contexts
% 
% for some related languages see also https://svn.kwarc.info/repos/stex/trunk/sty/etc/lstomdoc.sty
% 
% compiled by Christoph Lange (Universität Bremen, Jacobs University Bremen, University of Birmingham)
% 2010–2013
% math.semantic.web@gmail.com
% 
% https://github.com/clange/latex
% 
% For Mizar, see https://raw.github.com/JUrban/mizarmode/master/lstlangmizar.sty by Josef Urban

% Isabelle
% http://isabelle.in.tum.de
% partial specification; poor man's alternative to Isabelle's own LaTeX export
% but see also pmisabelle.sty
%\newif\iflst@instring\lst@instringfalse
%\newcommand*{\lst@eat}[1]{}%
%\newcommand*{\togglelst@instring}{%
%\upshape%
%\global\lst@instringfalse''
%}
\RequirePackage{xcolor}
\definecolor{IsabelleTypeColor}{HTML}{9f2ae5}
% Strings usually have this background color
% however listings has currently not support for selected background coloring
\definecolor{IsabelleStringBackground}{HTML}{535353}
\definecolor{IsabelleKeywordColor}{HTML}{2f769e}
\lstdefinelanguage{Isabelle}[]{ML}%
{morekeywords={%
abbreviation,% added by NM
assume,%
assumes,%
by,%
def,%
datatype,% added by NM
definition,% added by NM
fix,%
fixes,%
from,%
have,%
lemma,%
obtain,%
proof,%
partial\_function,%
qed,%
return,%
show,%
shows,%
theorem,%
typedef,%
try,%
unfolding,%
using,%
where,%
},
% modyfied to display highlighting inside strings
%morestring=**[d][\color{IsabelleStringBackground}]{"},
% and highlight type prefixes (')
%moredelim=[s][\color{IsabelleTypeColor}]{'}{\ },
%added by NM
moredelim=[s][\color{IsabelleStringBackground}]{(*}{*)},
basicstyle=\itshape,%
keywordstyle=\upshape\bfseries,%\color{IsabelleKeywordColor},%
columns=fullflexible,%
showstringspaces=false,%
mathescape,%
}[keywords,comments]


%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{A Verified Implementation of B$^+$-Trees in Isabelle/HOL} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Niels Mündler}{Department of Computer Science, ETH Zurich, Switzerland}{n.muendler@tum.de}{https://orcid.org/0000-0003-3851-2557}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Tobias Nipkow}{Department of Informatics, Technical University of Munich, Germany}{nipkow@in.tum.de}{https://orcid.org/0000-0003-0730-515X}{}

\author{Peter Lammich}{Department of Computer Science, The University of Manchester, Great-Britain}{lammich@in.tum.de}{https://orcid.org/0000-0003-3576-0504}{}

\authorrunning{N. Mündler, T. Nipkow and P. Lammich} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Niels Mündler} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\begin{CCSXML}
    <ccs2012>
       <concept>
           <concept_id>10003752.10003790.10011742</concept_id>
           <concept_desc>Theory of computation~Separation logic</concept_desc>
           <concept_significance>500</concept_significance>
           </concept>
     </ccs2012>
\end{CCSXML}
    
\ccsdesc[500]{Theory of computation~Separation logic}
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Separation Logic, Verification, Refinement} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\btree}{B$^+$-Tree}
\newcommand{\btrees}{B$^+$-Trees}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
    The abstract will surely become longer at some point.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

This will be the introduction. There will be more text.

\subsection{Related Work}
\label{sec:related_work}

Ernst verified a simplified version of \btrees that does
not have links between leaf nodes.

Malecha already built and verified \btrees \cite{}.
In their approach, they chose an intermediate layer of a functional
data structure that explicitely stores pointers to their heap embedded
correspondence.

\subsection{Contributions}
\label{sec:contributions}

We provide an alternative approach to verifying \btree implementations,
by separating the functional specification and the imperative implementation.
This allows for complex relationships to be validated on a purely
functional level, while on the imperative level
only refinement of the abstract operations needs to be shown.
The approach allowed us to supplement the implementation
with an efficient binary search on the node level
and eventually provide an efficient range query iterator
on top of a list element iterator.


\section{\btrees\ and Approach}
\label{sec:approach}

The \btree is a ubiquitous data structure to efficiently retrieve and manipulate
indexed data stored on storage devices with slow memory access \cite{DBLP:journals/csur/Comer79}.
They are $n$-ary balanced search trees, where $n$ is a free parameter.
We specify them as implementing a set interface,
where all elements in the leaves are comprising the content of an abstract set.
The inner nodes only contain separators to guide the recursive navigation through the tree.

Further the leaves usually contain pointers
to the next leaf, allowing for efficient iterators and range queries.

The goal of this work is to define this data structure
and implement and verify efficient heap-based imperative operations on them.
For this purpose, we introduce a functional, algebraic definition and
specify all invariants on this level.
It is important to note that this representation is not complete,
as we can not express the aliased pointers to the next leaf in a meaningful
way on the algebraic level.
However important structural invariants, such as sortedness and balancedness
can be verified.

In a second step an imperative definition is introduced,
that takes care of the refinement of linked lists to arrays in the heap
and introduces (potentially shared) pointers instead of algebraic structures.
Using a refinement relationship, we can prove that an imperative refinement
of the functional specification preserves the structural invariants
of the imperative tree on the heap.
The only remaining proof obligation on this level is to ensure the correctness
of the leaf pointers.


\subsection{Definitions}
\label{sec:data_structure_defs}

% TODO shorten

The algebraic \btree is defined as follows:

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-def]
    datatype 'a bplustree = LNode ('a list) | Node (('a bplustree * 'a) list) ('a bplustree)
\end{lstlisting}


Every node contains a list of \textit{keys} (also \textit{separators}, and \textit{subtrees} (\textit{children}),
that represent further \btree nodes.
The separators and subtrees may be considered interleaved within a node,
such that we can speak of a subtree to the left of a separator and
a subtree to the right of a separator,
where for a separator at index $i$ we mean the subtree in the respective
subtree list at index $i$ and $i+1$ respectively.
Note that this already implies that the list of subtrees is one
longer than the list of separators - we refer to the last subtree
as the \textit{last} or \textit{dangling} subtree.
The leafs contain a list of \textit{values}.
A \btree with above structure must fulfill the three properties
\textit{balancedness}, \textit{order} and \textit{sortedness}.

\textbf{Balancedness} requires
that each path from the root to any leaf has the same length $h$.
In other words, the height of all trees in one level of the tree must be equal,
where the height is the maximum path length to any leaf.

Further the keys and values must be \textbf{sorted} within the tree which means that all keys stored
in the subtree to the left of a separator are smaller than the value of the separator
and all indices in the subtree to the right are greater or equal.
\footnote{
    The exact direction of the part that may contain equal element is a design choice.
}
Further all keys within a node should maintain a sorted order,
as well as all the values within a leaf.

In general terms, the property of \textbf{order} ensures a certain minimum and maximum
number of subtrees for each node.
A \btree is of order $k$, if each internal node has at least $k+1$
subtrees and at most $2k+1$.
The root is required to have a minimum of 2 and a maximum of $2k+1$ subtrees.
We require that $k$ be strictly positive.
%TODO insert reason?

\section{Set operations}
\label{sec:set}

The most important operations on \btrees are point querys and insertion.
There is a canon on their implementation which we followed in our approach.
Deletion is less commonly implemented and even less verified,
however we provide an a functional definition of a correct deletion operation.

\subsection{Functional Point Query}
\label{sec:functional_pq}

The point query operation is straightforward and serves as an introduction
to Isabelle/HOL notation.
For an inner node, find the correct subtree which must contain
the searched value if it is in the tree.
Inside the leaf node, obtain the value directly from the list of values.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:isin-def]
fun isin:: "'a bplustree \<Rightarrow> 'a \<Rightarrow> bool" where
  "isin (LNode ks) x = (isin_list x ks)" |
  "isin (Node ts t) x = (
      case split ts x of (_,(sub,sep)#rs) \<Rightarrow> (
             isin sub x
      )
   | (_,[]) \<Rightarrow> isin t x
  )"
\end{lstlisting}

Note that we assume here that a "split" and "isin\_list" operation exist,
that somehow obtain from a sorted list of key-value pairs or keys
the correct subtree-separator pair or result of operation.
These operations trivially exists, for example based on a linear search.
We abstract the operations away here such that we can freely substitute them in a
later stage, even with a binary search implementation.

Since this operation does not modify the tree involved at all,
we only need to show that it returns the correct value.

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:isin-set-inorder]
theorem isin_set_inorder:
  assumes "sorted_less (leaves t)"
    and "aligned l t u"
  shows "isin t x = (x \<in> set (leaves t))"
\end{lstlisting}

%TODO imperative definition


The general goal of the verification is to express
all operations on an abstract level first.
We introduce a generic split function that does node-internal search
for us and provide operations on the whole tree based on them.

On the abstract level, the abstract functional specification
of the point query operation is straight forward.

% TODO functional definition

In order to verify these operations it was useful to further
abstract away structures of the tree.
Following Nipkows approach, we could ignore the internal structure of the tree
and provide proofs for the sortedness of the leaf elements purely
based on their respective refinement of sorted lists.
The internal structure of the trees, the navigation separators however,
cannot be abstracted away and require explicit proofs.


\subsection{Imperative Point Query}
\label{sec:imperative_pq}

The refinement of set operations is relatively straightforward and
follows in large parts the procedure in my BSCTHesis.

For point queries the refinement and its proof is easy
to show since the structure of the tree does not change.

\subsection{Functional Insert}
\label{sec:functional_insert}

The definition of insertion is largely lined up with the definition
of point queries.

\subsection{Imperative Insert}
\label{sec:imperative_insert}

One additional challenge here is to prove the correct initialization
and modification of pointers in the leaves,
as this cannot be proven on the abstract level, where these pointers
have no correspondence.


\section{Range operations}
\label{sec:range}

On the functional level, the forwarding leaf pointers in each leaf
are not present, as this would require aliasing.
Therefore, iterators merely compute the concatenation
of all leaf contents in the trivial manner.
Range iterators then concatenate the correct parts of the
abstract tree.
Only when refining the operations, we will make use of the leaf pointers
to obtain an efficient implementation.

\subsection{Iterators}
\label{sec:imperative_iter}

In order to be able to iterate over the leafs
a statement on the heap has to be made that relates
a leaf and all leafs in the linked list from there
to a tree rooted in some node.
For this purpose we follow the approach of malecha
to split the tree assertion into an equivalent assertion
on the inner nodes as well as only the concatenated leaf nodes.
In order to make use of the benefits of separation logic,
it is important that these statements only regard separated parts of the heap.

At this point a subtlety of the abstract refinement approach surfaces.
If we only have a statement about some pointers refining some abstract inner nodes
and a statement about some pointers refining some abstract leaf nodes - 
how can we guarantee that these pointers can be glued back together to form the
full abstract tree?

The point is, that we have a situation of aliasing now,
that is in general not well handled by separation logic.
However, we only need the content of one of the aliases, which again is fine
regarding separation logic.
The other statement then simply expresses "the pointer is the same as in the other statement"
which is not an overlapping statement regarding the heap.
Therefore we need to make the sharing here explicit,
obtaining the exact list of pointers in the imperative implementation
and pull them into the refinement relationship.
A nice fact is that we can always obtain this list even from the
refinement relationship that does not have it explicit,
and we can even ignore it again once we wrapped up the whole
iterator assertion into one definition.
To the user, this explicit sharing will hence never surface,
the user only interacts with the tree root pointer and the abstract tree.


Note here that while the abstract function copies the view on the leafs
upon recursing, the obtained iterator does not.
However this is not an issue, as they are only related abstractly.

\subsection{Range operations}
\label{sec:imperative_range}

One interesting note on the range iterators is, that a
straightforward proof of the correctness of the exact range iterator
failed at the attempt to recursively make a statement on
the leaf element iterators on the subtree.
A workaround is to just make a statement about the split tree first,
and later obtain the iterator only from manipulating the obtained leaf node.
This lead to the functional level being extended by two functions,
one that obtained the correct leaf node for the range iteration
and another one that manipulated the leaf node to obtain
the correct element-level iterator on all values.
On a second attempt, these two functions could then be imperatively
refined and verified.
Their concatenation then yields the intended result at no extra cost.

\section{Code extraction}

\subsection{Binary internal search}
\label{sec:imperative_split}

Due to the high abstraction of the proofs,
we can now provide different node internal search algorithms,
as long as they guarantee the required properties of the split function.
To this end we provide a linear search algorithm
and a binary search, the latter being commonly used in real world applications.

\subsection{Code export}
\label{sec:code_export}

From the imperative code shown,
Isabelle/HOL allows exports to a number of languages.

% TODO some analysis of the code generated? even necessary?

\section{Comparison and Conclusion}
\label{sec:conclusion}

We were able to define and verify a number of efficient operations
on imperative \btrees.
Namely we provide the basics with point and insertion querys.
Further we provide an efficient iterator on the leafs
and even give a range operation for a lower bound that
can be trivially extended to support an upper bound.
All operations are conducted on a \btree with linked leafs,
and conduct binary search within each node.

\end{document}
